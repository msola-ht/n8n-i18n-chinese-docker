name: 构建 n8n 中文编辑器 UI Docker 镜像

on:
  workflow_dispatch: # 允许手动触发
  schedule:
    - cron: '0 * * * *'  # 每小时检查一次，例如 UTC 时间每小时的第0分钟

env:
  UPSTREAM_REPO: other-blowsnow/n8n-i18n-chinese # 上游仓库地址

jobs:
  build-and-push:
    runs-on: ubuntu-latest # 在 Ubuntu 最新版系统上运行

    steps:
    - name: 拉取当前仓库代码 # 步骤1: 拉取当前仓库代码
      uses: actions/checkout@v3
      with:
        fetch-depth: 0 # 获取所有历史，包括标签，以便检查

    - name: 获取上游最新发布信息 # 步骤2: 从上游仓库获取最新发布信息
      id: get_release
      run: |
        latest_release=$(curl -s https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/releases/latest)
        # 使用 xargs 确保去除所有前导和尾部空格
        tag=$(echo "$latest_release" | jq -r .tag_name | xargs) # 获取上游的 Git Tag，例如 n8n@1.115.3
        asset_url=$(echo "$latest_release" | jq -r '.assets[] | select(.name|endswith(".tar.gz")) | .browser_download_url' | xargs) # 获取下载链接
        echo "tag=$tag" >> "$GITHUB_OUTPUT" # 将tag设置为输出
        echo "asset_url=$asset_url" >> "$GITHUB_OUTPUT" # 将下载链接设置为输出
        echo "检测到上游标签: '$tag'" # 打印带引号的tag，方便调试空格

    - name: 检查此版本是否已发布 # 新增步骤：检查当前仓库是否已存在与上游最新 release 相同的 Git Tag
      id: check_tag
      run: |
        UPSTREAM_TAG="${{ steps.get_release.outputs.tag }}"
        echo "正在检查当前仓库是否已存在 Git Tag: '$UPSTREAM_TAG'"
        # 使用 git ls-remote 检查远程仓库（origin）中是否存在该标签
        # grep -q 用于静默输出，只返回退出状态码
        if git ls-remote --tags origin | grep -q "refs/tags/$UPSTREAM_TAG$"; then
          echo "检测到标签 '$UPSTREAM_TAG' 已存在于当前仓库，此版本已发布过。"
          echo "exists=true" >> "$GITHUB_OUTPUT"
        else
          echo "标签 '$UPSTREAM_TAG' 不存在于当前仓库，将继续构建新版本。"
          echo "exists=false" >> "$GITHUB_OUTPUT"
        fi

    - name: 提示：此版本已发布，将跳过后续构建步骤 # 修改此步骤名称，使其更明确
      if: steps.check_tag.outputs.exists == 'true' # 只有当已发布时才执行此提示
      run: |
        echo "检测到上游最新版本已在当前仓库发布过，无需重复构建和推送。后续构建步骤将被跳过。"
        # 注意：此处不再使用 exit 0 来终止整个 Job，而是通过后续步骤的 if 条件来控制跳过。

    # 以下所有步骤都添加了 if 条件，只有在版本未发布时才执行
    - name: 从标签中提取 n8n 版本号 # 步骤3: 从上游Git标签中提取纯粹的n8n版本号
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      id: get_n8n_version
      run: |
        TAG_REF="${{ steps.get_release.outputs.tag }}"
        # 提取后再次使用 xargs 确保去除所有前导和尾部空格
        N8N_VERSION=$(echo "${TAG_REF#n8n@}" | xargs) # 提取出 '1.115.3'
        echo "n8n_version=$N8N_VERSION" >> "$GITHUB_OUTPUT" # 将版本号设置为输出
        echo "提取到的 n8n 版本号: '$N8N_VERSION'" # 打印带引号的版本号，方便调试空格

    - name: 调试 Docker Hub 用户名 # 步骤4: 检查 DOCKERHUB_USERNAME 是否有空格，并清理
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      run: |
        DOCKERHUB_USERNAME_VAL="${{ secrets.DOCKERHUB_USERNAME }}"
        echo "--- 调试 Docker Hub 用户名 ---"
        echo "用户名 (带引号): '$DOCKERHUB_USERNAME_VAL'"
        echo "用户名长度: ${#DOCKERHUB_USERNAME_VAL}"
        echo "------------------------------------"
        # 增加一个防御性处理，确保 DOCKERHUB_USERNAME 不包含空格，并输出到环境变量
        CLEAN_DOCKERHUB_USERNAME=$(echo "$DOCKERHUB_USERNAME_VAL" | xargs)
        echo "清理后的用户名 (带引号): '$CLEAN_DOCKERHUB_USERNAME'"
        echo "清理后的用户名长度: ${#CLEAN_DOCKERHUB_USERNAME}"
        echo "DOCKERHUB_USERNAME=$CLEAN_DOCKERHUB_USERNAME" >> "$GITHUB_ENV" # 将清理后的用户名设置为环境变量，供后续步骤使用

    - name: 下载上游发布文件 # 步骤5: 下载上游的 editor-ui dist 文件
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      run: |
        mkdir -p src-dist
        curl -L "${{ steps.get_release.outputs.asset_url }}" -o src-dist/editor-ui.tar.gz
        echo "已下载 ${{ steps.get_release.outputs.asset_url }}"

    - name: 解压 dist 文件 # 步骤6: 解压下载的 tar.gz 文件
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      run: |
        tar -xzvf src-dist/editor-ui.tar.gz -C src-dist
        echo "已解压 dist 文件到 src-dist/dist"

    - name: 生成 Dockerfile (多阶段构建) # 步骤7: 动态生成 Dockerfile，现在使用多阶段构建
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      run: |
        N8N_VERSION=${{ steps.get_n8n_version.outputs.n8n_version }} # 使用提取出的纯粹版本号
        echo "正在为 n8n 版本: $N8N_VERSION 生成多阶段 Dockerfile"
        cat <<EOF > Dockerfile
        # --- 阶段 1: ui_holder (用于从构建上下文复制 dist 文件) ---
        # 这一阶段使用一个轻量级的基础镜像，只为了“持有”我们已下载和解压的 dist 文件。
        # 这样做可以确保最终镜像只包含这些文件，而不是整个 src-dist 目录的临时内容。
        FROM alpine:latest as ui_holder
        WORKDIR /app
        # 将 GitHub Actions Runner 上已存在的 src-dist/dist 目录复制到这一阶段的镜像中
        COPY src-dist/dist /app/dist

        # --- 阶段 2: Final n8n Image (最终镜像) ---
        FROM n8nio/n8n:$N8N_VERSION
        USER root

        RUN apk update \\
            && apk add --no-cache ffmpeg \\
            && rm -rf /var/cache/apk/*

        USER node

        # 从 ui_holder 阶段复制纯净的 dist 文件到 n8n 的 editor-ui 目录
        COPY --from=ui_holder /app/dist /usr/local/lib/node_modules/n8n/node_modules/n8n-editor-ui/dist
        EOF
        cat Dockerfile # 打印生成的 Dockerfile 内容以供调试

    - name: 设置 Docker Buildx # 步骤8: 设置Docker Buildx，用于更高效和安全的构建
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      uses: docker/setup-buildx-action@v3

    - name: 登录到 Docker Hub # 步骤9: 登录到Docker Hub
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: 调试最终镜像标签 # 步骤10: 打印最终的标签字符串，方便调试
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      run: |
        # 使用通过 $GITHUB_ENV 设置的清理后的 DOCKERHUB_USERNAME
        echo "--- 调试最终镜像标签 ---"
        echo "版本标签: '${{ env.DOCKERHUB_USERNAME }}/n8n-chinese:${{ steps.get_n8n_version.outputs.n8n_version }}'"
        echo "最新标签: '${{ env.DOCKERHUB_USERNAME }}/n8n-chinese:latest'"
        echo "----------------------------------"

    - name: 构建并推送 Docker 镜像 # 步骤11: 构建并推送Docker镜像 (同时打上版本号和latest标签)
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      uses: docker/build-push-action@v5 # 推荐使用此官方action，一步完成构建和推送
      with:
        context: . # Dockerfile 所在的上下文路径
        push: true # 启用推送
        # 定义要推送的标签，每行一个
        tags: |
          ${{ env.DOCKERHUB_USERNAME }}/n8n-chinese:${{ steps.get_n8n_version.outputs.n8n_version }}
          ${{ env.DOCKERHUB_USERNAME }}/n8n-chinese:latest
        cache-from: type=gha # 启用GitHub Actions缓存
        cache-to: type=gha,mode=max # 将构建缓存写入GitHub Actions

    - name: 更新 README 文件中的版本号 # 步骤12: 更新README中的版本标签
      if: steps.check_tag.outputs.exists == 'false' # 只有在未发布时才执行
      run: |
        NEW_VERSION="${{ steps.get_n8n_version.outputs.n8n_version }}"
        DOCKER_USER="${{ env.DOCKERHUB_USERNAME }}" # 获取清理后的 Docker Hub 用户名
        echo "正在更新 README.md 版本至: $NEW_VERSION (Docker 用户: $DOCKER_USER)"

        # 更新 README.md 中的版本标签
        # 动态替换 Docker 用户名和版本号
        # 注意：这里使用 sed 命令时，如果 DOCKER_USER 包含特殊字符，可能会需要额外的转义。
        # 假设 DOCKER_USER 是标准的 Docker Hub 用户名，不包含 sed 的特殊字符。
        sed -i "s|${DOCKER_USER}/n8n-chinese:[0-9]\+\.[0-9]\+\.[0-9]\+|${DOCKER_USER}/n8n-chinese:$NEW_VERSION|g" README.md

        # 显示更新内容
        echo "更新后的 README.md 内容片段:"
        grep -n "${DOCKER_USER}/n8n-chinese:" README.md || true

        # 配置 Git 用户信息
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

        # 提交更新
        git add README.md
        if git diff --staged --quiet; then
          echo "README.md 没有变化。"
        else
          echo "🤖 自动更新 README 版本标签至 ${NEW_VERSION}" > commit_message.txt
          echo "" >> commit_message.txt
          echo "- 更新所有 ${DOCKER_USER}/n8n-chinese 版本标签引用" >> commit_message.txt
          echo "- 版本号: ${NEW_VERSION}" >> commit_message.txt
          echo "- 自动构建流程更新" >> commit_message.txt
          echo "" >> commit_message.txt
          echo "🤖 由 GitHub Actions 生成" >> commit_message.txt
          echo "" >> commit_message.txt
          echo "Co-Authored-By: GitHub Action <action@github.com>" >> commit_message.txt

          git commit -F commit_message.txt
          rm commit_message.txt
          # 推送新的 Git Tag 到当前仓库，以标记此版本已处理
          git tag "${{ steps.get_release.outputs.tag }}" # 使用上游的 tag 作为当前仓库的 tag
          git push origin "${{ steps.get_release.outputs.tag }}" # 推送新创建的 Git Tag
          git push # 推送 README.md 的更新
        fi
